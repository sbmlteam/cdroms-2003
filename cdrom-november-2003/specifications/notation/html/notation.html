<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.2beta8 (1.46)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Contents</TITLE>
<META NAME="description" CONTENT="Contents">
<META NAME="keywords" CONTENT="notation">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.2beta8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="notation.css">

</HEAD>

<BODY  BGCOLOR="#ffffff">

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>
<BR>

<P>
<HR NOSHADE>
<H1 ALIGN="CENTER">SCHUCS: A UML-Based Approach for Describing
<BR>
Data Representations Intended for XML Encoding</H1>
<HR NOSHADE>
<P ALIGN="CENTER"><STRONG>Michael Hucka</STRONG></P>
<P ALIGN="CENTER"><TT>mhucka@caltech.edu</TT></P>
<P ALIGN="CENTER"><SMALL>Systems Biology Workbench Development Group
<BR>
ERATO Kitano Systems Biology Project
<BR>
Control and Dynamical Systems, MC 107-81
<BR>
California Institute of Technology, Pasadena, CA 91125</SMALL></P>
<P ALIGN="CENTER"><SMALL>Principal Investigators: John Doyle and Hiroaki Kitano</SMALL></P>
<P ALIGN="CENTER"><STRONG>Version of 11 December 2000</STRONG></P>
<BR>

<H2><A NAME="SECTION00000000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html38"
  HREF="notation.html">1 Introduction</A>
<LI><A NAME="tex2html39"
  HREF="#SECTION00020000000000000000">2 Representing Object Structures in XML</A>
<UL>
<LI><A NAME="tex2html40"
  HREF="#SECTION00021000000000000000">2.1 Basis of the Approach</A>
</UL>
<LI><A NAME="tex2html41"
  HREF="#SECTION00030000000000000000">3 The UML-Based Notation and Its Textual and XML Forms</A>
<UL>
<LI><A NAME="tex2html42"
  HREF="#SECTION00031000000000000000">3.1 Simple Attributes</A>
<LI><A NAME="tex2html43"
  HREF="#SECTION00032000000000000000">3.2 Complex Attributes</A>
<LI><A NAME="tex2html44"
  HREF="#SECTION00033000000000000000">3.3 Links</A>
<LI><A NAME="tex2html45"
  HREF="#SECTION00034000000000000000">3.4 Inclusion</A>
<LI><A NAME="tex2html46"
  HREF="#SECTION00035000000000000000">3.5 Lists</A>
<LI><A NAME="tex2html47"
  HREF="#SECTION00036000000000000000">3.6 Element Values</A>
<LI><A NAME="tex2html48"
  HREF="#SECTION00037000000000000000">3.7 Constraints on Attribute Values</A>
<LI><A NAME="tex2html49"
  HREF="#SECTION00038000000000000000">3.8 Specifying Units</A>
<LI><A NAME="tex2html50"
  HREF="#SECTION00039000000000000000">3.9 Inheritance</A>
</UL>
<LI><A NAME="tex2html51"
  HREF="#SECTION00040000000000000000">4 Summary</A>
<LI><A NAME="tex2html52"
  HREF="#SECTION00050000000000000000">5 Acknowledgements</A>
<LI><A NAME="tex2html53"
  HREF="#SECTION00060000000000000000">A. References</A>
<LI><A NAME="tex2html54"
  HREF="#SECTION00070000000000000000">About this document ...</A>
</UL>
<!--End of Table of Contents-->
<H1><A NAME="SECTION00010000000000000000"></A> 
<A NAME="sec:introduction"></A>
<BR>
1 Introduction
</H1>

<P>
One component of the ERATO Kitano Systems Biology Project is the creation
of a workbench that provides interoperability between a number of
simulation packages.  Developing a framework for database storage and
inter-program exchange requires defining a language for communicating data.
Defining this language requires first establishing a notation that humans
can use to describe the data structures involved.

<P>
I propose a notation to be used for describing data structures that are
intended to be encoded using XML, the Extensible Markup Language&nbsp;(Bosak and
Bray, 1999; Bray, Paoli and Sperberg-McQueen, 1998; Fallside, 2000).  The
notation is based in part on a subset of UML, the Unified Modeling
Language&nbsp;(Eriksson, 1998; Oestereich, 1999), a visual language for
specifying software systems.  There are three main advantages to using UML
class diagrams as a basis for defining data structures.  First, compared to
using other notations or a programming language, the UML visual
representations are generally easier to read and understand by readers who
are not computer scientists.  Second, the visual notation is
implementation-neutral--the defined structures can be encoded in any
concrete implementation language, not just XML but other formats as well,
making the UML-based definitions more useful and flexible.  Third, UML is a
de facto industry standard&nbsp;(OMG, 2000), documented in many books and
available in many software tools including mainstream development
environments (such as Microsoft Visual Basic 5 Enterprise Edition).
Readers are therefore more likely to be familiar with it than other
notations.

<P>
Readers do not need to know UML in advance; this document provides
descriptions of all the constructs used.  The notation presented here can
be expressed not only in graphical diagram form (which is what UML is all
about) but also in textual form, allowing descriptions to be easily written
in a text editor and sent as plain-text email.

<P>
The scope of the notation is limited to classes and their attributes, not
class methods or operations.  One of the goals of this effort has been to
develop a consistent, systematic method for translating UML-based class
diagrams into XML Schemas.  Another goal has been to maintain a reasonably
simple notation and UML-to-XML mapping.  An important side-effect of this
is that the vocabulary of the notation is purposefully limited to only a
small number of constructs.  It is explicitly <I>not</I> intended to cover
the full power of UML or XML.  This limited vocabulary has nevertheless
been sufficient for the applications to which it has been applied so far in
the Systems Biology workbench project.

<P>

<H1><A NAME="SECTION00020000000000000000"></A>
<A NAME="sec:representing"></A>
<BR>
2 Representing Object Structures in XML
</H1>

<P>
XML provides the ability to define hierarchically-nested structures; this
works well for representing object-oriented data because objects are
basically nested field-value structures.  An XML data stream or document
consists of a series of descriptions of data objects.  The structure of the
data stream, meaning the permitted vocabulary and organization of entities
in the stream, can be optionally predefined in the form of either a
<I>Document Type Definition</I> or an <I>XML Schema</I>.

<P>
An <I>XML Schema</I> (Biron and Malhotra, 2000; Fallside, 2000; Thompson et
al., 2000) is used to specify the kinds of objects allowed in an XML data
stream, as well as how the objects and their properties are to be organized
and the types of values that can be assigned to the object attributes.  It
provides more expressive power than the alternative mechanism for defining
XML structures, the document type definition (DTD).

<P>
The following is an example XML Schema definition for a simple kind of data
object:
<BR>
<IMG
 WIDTH="412" HEIGHT="146" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.gif"
 ALT="\begin{example}
&lt;xs:schema xmlns:xs=''http://www.w3.org/1999/XMLSchema''&gt;
\par &lt;...
...s:element name=''Object'' type=''ObjectClass''/&gt;
\par &lt;/xs:schema&gt;
\end{example}">
<BR>
This definition begins with a qualified element, <code>xs:schema</code>, that
tells an XML parser that the rest of the stream is an XML Schema
definition.  The symbols that belong to the XML Schema standard are
prefixed with the characters ``<code>xs:</code>''.  The use of <code>xs:</code> in
particular, rather than some other prefix, is set by the
<code>xmlns:xs="..."</code> portion of the first line.  This is a
<I>namespace</I> specification that communicates to the parser that the
prefixed symbols belong to the space of symbols defined for XML Schema.
The rest of the Schema defines an object class unimaginatively called
<code>ObjectClass</code> having two attributes <code>attributeA</code> and
<code>attributeB</code>.  The second-to-last line states that an instance of an
XML data stream based on this Schema definition can contain one top-level
object, called <code>Object</code>, constructed according to the class
<code>ObjectClass</code>.

<P>
Attribute types and other characteristics are defined in the following
sections, along with principles for combining them and defining object
classes.  For brevity, in the rest of this document, only the relevant XML
Schema definitions are given, without enclosing
<code>&lt;xs:schema ...&gt; ... &lt;/xs:schema&gt;</code> wrappers and without explicit
definition of top-level objects that use the object classes defined.

<P>
Although it is extremely powerful, the XML Schema language (and for that
matter, the DTD language) is complicated and not suitable as a descriptive
specification language for humans communicating about data structures used
in a software project.  A more suitable language is UML, but there does not
exist an agreed-upon approach for translating object classes represented in
UML class diagrams into XML Schemas.  The rest of this document presents
one viable approach.

<P>

<H2><A NAME="SECTION00021000000000000000"></A>
<A NAME="sec:xml"></A>
<BR>
2.1 Basis of the Approach
</H2>

<P>

<P></P>
<DIV ALIGN="CENTER">
r1.5 in
  <DIV ALIGN="CENTER">
<!-- MATH
 $\includegraphics[scale = 0.7]{sampleschema}$
 -->
<IMG
 WIDTH="145" HEIGHT="83" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.gif"
 ALT="\includegraphics[scale = 0.7]{sampleschema}">
</DIV>
</DIV>
<P></P>
An instance of a data object is always constructed according to a blueprint
or <I>class</I> definition that specifies the internal structure of the
object.  The ``structure'' is its attributes and the types of data values
that are permitted to be stored in the attributes.  In UML notation, a
class is represented as a box with a title and a list of attributes below
it, as in the example shown at right.  The example shows an object class
named <TT>Sample</TT> having three attributes: <TT>title</TT>,
<TT>description</TT>, and <TT>sampleValue</TT>.  A full class definition
would also include a list of operations or methods that an object
understands, but the scope of the present effort is limited to data
attributes only.

<P>

<P>
In XML, objects in a document or data stream are referred to as
<I>elements</I>.  Elements can contain values that may themselves be other
elements, and elements can have annotations in the form of attributes.  The
following snippet of XML illustrates the different parts of an XML
representation:
<BR>
<IMG
 WIDTH="524" HEIGHT="71" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.gif"
 ALT="\begin{example}
&lt;element1 attributeA=''attributeA-value''&gt;element1-value&lt;/elemen...
...ributeD=''attributeD-value''&gt;element4-value&lt;/element4&gt;
&lt;/element2&gt;
\end{example}">
<BR>
The example above shows four separate elements.  Some of the elements have
attributes (<TT>element1</TT>, <TT>element2</TT>, <TT>element4</TT>), while
others do not (<TT>element3</TT>).  Some of the elements have simple values
(<TT>element1</TT>, <TT>element3</TT>, <TT>element4</TT>), while the other
one (<TT>element2</TT>) contains two other elements (<TT>element3</TT>,
<TT>element4</TT>) as its value.

<P>
XML element attributes are name-value pairs that can only be used to hold
simple (scalar) values.  Storing a value that is more structured (e.g.,
another object) requires the use of a subelement.  When encoding a UML data
structure in XML, an attribute in the UML structure may or may not be made
into an XML element attribute.  Indeed, one of the first questions that
needs to be answered when developing an XML format is: what should be
stored as element attributes, and what should be stored as element values?

<P>
There is no agreed-upon rule to answer this question.  Some authors lean
towards using element values to store content and attributes to store
annotations about the elements (Box, Skonnard and Lam, 2000; St.&nbsp;Laurent,
2000).  But this is not universally accepted&nbsp;(Cover, 2000), and in fact,
one of the original architects of XML has stated that ``I've never heard a
convincing universal decision procedure for what should be an element and
what an attribute''&nbsp;(Bray, 1998).  Instead of representing data object
attributes as separate XML elements, it is also valid to represent them as
a collection of attributes on a single element.  To put this into concrete
terms, here are two XML samples that can both be taken to express the same
data:
<DIV ALIGN="CENTER">

  </FONT></DIV>
<DIV ALIGN="CENTER"><FONT SIZE="-1">
<BR><FONT SIZE="-1">  <BR>
  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="173">
<TR><TD>
      <PRE><TT>
        <code>&lt;Sample&gt;</code>
<BR><code>&lt;title&gt;My title&lt;/title&gt;</code>
<BR><code>&lt;description&gt;My description&lt;/description&gt;</code>
<BR><code>&lt;sampleValue&gt;42&lt;/sampleValue&gt;</code>
<BR><code>&lt;/Sample&gt;</code>      
</TT></PRE></TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="173">
<TR><TD>
      <PRE><TT>
        <code>&lt;Sample title="My title"</code>
<BR><code>description="My description"</code>
<BR><code>sampleValue="42"/&gt;</code>      
</TT></PRE></TD></TR>
</TABLE><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    <I>Approach 1</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>Approach 2</I>
  </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE></DIV>
The second approach is a more compact encoding, in part because it can be
written using a short format, <TT>&lt;tag .../&gt;</TT>, instead of the full
nested tag pair <TT>&lt;tag ...&gt;&lt;/tag&gt;</TT>; the shorter format is allowed
when an XML element does not have a value.  The approach also leads to a
direct correspondence between object attributes and XML element attributes:
when we speak about an ``attribute'' of an object, the corresponding XML
construct is usually an attribute on an element, as in the example on the
right above.  For these reasons, the notation presented here is based on
the second approach.

<P>

<H1><A NAME="SECTION00030000000000000000"></A>
<A NAME="sec:schemas"></A>
<BR>
3 The UML-Based Notation and Its Textual and XML Forms
</H1>

<P>
The following example presents an object class definition in the UML-style
notation adopted here, along with its representation in a textual form and
in XML Schema syntax:

<P>
<DIV ALIGN="CENTER">
</FONT></DIV>
<DIV ALIGN="CENTER"><FONT SIZE="-1">
<BR><FONT SIZE="-1">   
  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="150">
<TR><TD>
      <!-- MATH
 $\includegraphics[scale = 0.7]{sampleschema}$
 -->
<IMG
 WIDTH="145" HEIGHT="83" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.gif"
 ALT="\includegraphics[scale = 0.7]{sampleschema}">
    </TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="173">
<TR><TD>
      <PRE><TT>
        <TT>Sample</TT>
<BR>
<BR><TT>title</TT>:		<TT>string</TT>
<BR><TT>description</TT>:		<TT>string</TT>
<BR><TT>sampleValue</TT>:		<TT>integer</TT>      
</TT></PRE></TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="346">
<TR><TD>
      <PRE><TT>
        <code>&lt;xs:complexType name="Sample"&gt;</code>
<BR><code>&lt;xs:attribute name="title" type="xs:string"/&gt;</code>
<BR><code>&lt;xs:attribute name="description" type="xs:string"/&gt;</code>
<BR><code>&lt;xs:attribute name="sampleValue" type="xs:integer"/&gt;</code>
<BR><code>&lt;/xs:complexType&gt;</code>      
</TT></PRE></TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    </FONT></TD>
<TD></TD>
<TD></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    <I>UML Form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>Textual Form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>XML Schema Form</I>
  </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></DIV>
<DIV ALIGN="CENTER"></DIV>

<P>
All three forms define the same data structure: a class <TT>Sample</TT> of
objects having three attributes <TT>title</TT>, <TT>description</TT> and
<TT>sampleValue</TT>.  The components are named according to a particular
naming convention.  First, the name of the class must begin with an
uppercase letter, can contain letters, numerals and underscore characters,
and (due to limitations in the software tools we are using) cannot contain
other types of characters.  Words within the names should each be
capitalized.  Second, attribute names generally begin with a lowercase
letter but otherwise follow the convention for class names; for
example, an attribute might be named <TT>sampleValue</TT>.  An exception to
this rule can be made when the attribute name begins with a word that is
normally capitalized, such as an acronym or symbolic name (e.g.,
``<TT>Q10Scaling</TT>'').

<P>
Attributes are typed.  There are a number of possible datatypes, as
explained in
Sections&nbsp;<A HREF="notation.html#sub:simple-attributes">3.1</A>-<A HREF="notation.html#sub:list-attributes">3.5</A>.  The type
specifier is written after the name of the attribute, as in, for example,
<TT>title: string</TT>.  This convention is commonly used in UML textbooks
(e.g., Eriksson and Penker, 1998) and software tools.  An alternative UML
style puts the type specifier before the attribute name, as in, for
instance, <TT>string title</TT>.

<P>

<P></P>
<DIV ALIGN="CENTER">
r1.4 in
  <DIV ALIGN="CENTER">  <!-- MATH
 $\includegraphics[scale = 0.7]{sampleschema-abstract}$
 -->
<IMG
 WIDTH="145" HEIGHT="83" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.gif"
 ALT="\includegraphics[scale = 0.7]{sampleschema-abstract}">
</DIV>
</DIV>
<P></P>
It is sometimes useful to specify that an object class is <I>abstract</I>,
meaning that it is only intended to serve as a basis for defining other
classes and not to be instantiated directly into objects.  In such cases,
the class name is written in an italic or slanted typeface, as in the
example shown at right.  In XML, abstract classes are defined by adding
<TT>abstract="true"</TT> to the type definition:
<BR>
<IMG
 WIDTH="344" HEIGHT="42" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''Sample'' abstract=''true''&gt;
...
&lt;/xs:complexType&gt;
\end{example}">
<BR>
To express in the textual form of this notation that a class is abstract,
the name of the class should be followed by the annotation
<TT>{abstract}</TT> following the name of the class, as in
<TT>Sample {abstract}</TT>.

<P>

<H2><A NAME="SECTION00031000000000000000"></A>
<A NAME="sub:simple-attributes"></A>
<BR>
3.1 Simple Attributes
</H2>

<P>

<P></P>
<DIV ALIGN="CENTER"><A NAME="fig:simple-types"></A><A NAME="687"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Simple types built into XML Schema, according to the W3C Working
    Draft of 7 April 2000.  Detailed definitions of these types are
    available at <TT><A NAME="tex2html2"
  HREF="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</A></TT>.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">  <FONT SIZE="-1">   
  </FONT><TABLE CELLPADDING=3 ALIGN="CENTER">
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    
    </FONT><TABLE  WIDTH="346">
<TR><TD>
      <BR><TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT">&nbsp;</TD><TH ALIGN="LEFT"><B>Type</B></TH>
<TH ALIGN="LEFT"><B>Example(s)</B></TH>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">binary</TD>
<TD ALIGN="LEFT"><TT>100010</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">boolean</TD>
<TD ALIGN="LEFT"><TT>true, false, 1, 0</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">byte</TD>
<TD ALIGN="LEFT"><TT>-1, 126</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">century</TD>
<TD ALIGN="LEFT"><TT>19</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">date</TD>
<TD ALIGN="LEFT"><TT>1999-05-31, --05</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">decimal</TD>
<TD ALIGN="LEFT"><TT>-1.23, 0, 123.4, 1000.00</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">double</TD>
<TD ALIGN="LEFT"><TT>-INF, -0, 0, 1.7E-2, 3, INF, NaN</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">ENTITIES</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">ENTITY</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">float</TD>
<TD ALIGN="LEFT"><TT>-INF, -0, 0, 1.7E-2, 3, INF, NaN</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">ID</TD>
<TD ALIGN="LEFT"><TT>m32</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">IDREF</TD>
<TD ALIGN="LEFT"><TT>m32</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">IDREFS</TD>
<TD ALIGN="LEFT"><TT>m32 m33 m34 m35</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">int</TD>
<TD ALIGN="LEFT"><TT>-1, 126789675</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">integer</TD>
<TD ALIGN="LEFT"><TT>-126789, -1, 0, 1, 126789</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">language</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">long</TD>
<TD ALIGN="LEFT"><TT>-1, 12678967543233</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">month</TD>
<TD ALIGN="LEFT"><TT>1999-05</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">Name</TD>
<TD ALIGN="LEFT"><TT>shipTo</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">NCName</TD>
<TD ALIGN="LEFT"><TT>Address</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">negativeInteger</TD>
<TD ALIGN="LEFT"><TT>-126789, -1</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE>
       </TD></TR>
</TABLE><FONT SIZE="-1">
     </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">
     </FONT><TABLE  WIDTH="346">
<TR><TD>
       <BR><TABLE CELLPADDING=3 BORDER="1" ALIGN="CENTER">
<TR><TD ALIGN="LEFT">&nbsp;</TD><TH ALIGN="LEFT"><B>Type</B></TH>
<TH ALIGN="LEFT"><B>Example(s)</B></TH>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">NMTOKEN</TD>
<TD ALIGN="LEFT"><TT>US</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">NMTOKENS</TD>
<TD ALIGN="LEFT"><TT>US UK</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">nonNegativeInteger</TD>
<TD ALIGN="LEFT"><TT>0, 1, 126789</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">nonPositiveInteger</TD>
<TD ALIGN="LEFT"><TT>-126789, -1, 0</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">NOTATION</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">positiveInteger</TD>
<TD ALIGN="LEFT"><TT>1, 126789</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">QName</TD>
<TD ALIGN="LEFT"><TT>po:Address</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">recurringDate</TD>
<TD ALIGN="LEFT"><TT>-05-31</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">recurringDay</TD>
<TD ALIGN="LEFT"><TT>--31</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">recurringDuration</TD>
<TD ALIGN="LEFT"><TT>-05-31T13:20:00</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">short</TD>
<TD ALIGN="LEFT"><TT>-1, 12678</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">string</TD>
<TD ALIGN="LEFT"><TT>This is a string</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">time</TD>
<TD ALIGN="LEFT"><TT>13:20:00.000-05</TT>:00</TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">timeDuration</TD>
<TD ALIGN="LEFT"><TT>P1Y2M3DT10H30M12.3S</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">timeInstant</TD>
<TD ALIGN="LEFT"><TT>1999-05-31T13:20:0.0-05:00</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">timePeriod</TD>
<TD ALIGN="LEFT"><TT>1999-05-31T13:20</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">unsignedByte</TD>
<TD ALIGN="LEFT"><TT>0, 126</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">unsignedInt</TD>
<TD ALIGN="LEFT"><TT>0, 1267896754</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">unsignedLong</TD>
<TD ALIGN="LEFT"><TT>0, 12678967543233</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">unsignedShort</TD>
<TD ALIGN="LEFT"><TT>0, 12678</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">uriReference</TD>
<TD ALIGN="LEFT"><TT>http://www.me.com/x.html#id5</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT">year</TD>
<TD ALIGN="LEFT"><TT>1999</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE>
       </TD></TR>
</TABLE></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></DIV></TD></TR>
</TABLE>
</DIV><P></P>

<P>
A simple attribute is one having a simple data value, for instance a number
or a string.  All three of the attributes shown in the <TT>Sample</TT>
example above are simple attributes.  The set of simple types that are
permitted is the set defined by the XML Schema Datatypes standard (Biron
and Malhotra, 2000) plus simple types derived from the built-in ones.
Figure&nbsp;<A HREF="notation.html#fig:simple-types">1</A> lists the simple types built into XML Schema.

<P>

<H2><A NAME="SECTION00032000000000000000"></A>
<A NAME="sub:complex-attributes"></A>
<BR>
3.2 Complex Attributes
</H2>

<P>
An attribute in an object can be a container for a collection of attributes
under a common heading.  In that case, the attribute is said to be
<I>complex</I> because its value is not a simple scalar.  This is roughly
equivalent to a ``struct'' in the language C.

<P>
In UML, a complex type is defined as a separate class.  The following is an
example of a class, <TT>MyTest</TT>, having three attributes,
<TT>attributeA</TT>, <TT>attributeB</TT> and <TT>attributeC</TT>.  The
first two attributes have simple types, and the third attribute's type is a
newly-defined class, <TT>AttrCType</TT>, itself containing two more
attributes.
<BLOCKQUOTE>
<!-- MATH
 $\includegraphics[scale = 0.7]{someschema-uml}$
 -->
<IMG
 WIDTH="398" HEIGHT="80" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.gif"
 ALT="\includegraphics[scale = 0.7]{someschema-uml}">
</BLOCKQUOTE>
In a programming language, given an object <TT>obj</TT> of class
<TT>MyTest</TT>, the attributes might be accessed as
<BR>
<IMG
 WIDTH="254" HEIGHT="57" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.gif"
 ALT="\begin{example}
obj.attributeA
obj.attributeB
obj.attributeC.anotherAttribute
obj.attributeC.yetAnotherAttribute
\end{example}">
<BR>

<P>
As explained in Section&nbsp;<A HREF="notation.html#sec:xml">2.1</A>, simple attributes in UML class
definitions are translated into element attributes in XML.  Complex types
translate directly into the <TT>complexType</TT> element in XML Schemas.
However, in XML, an element attribute cannot have a complex type, which
means that a complex attribute in the present notation must be made into an
XML <I>subelement</I> within the containing XML element.  This leads to the
question of how to name and structure the subelement.  The approach taken
here is to name the subelement after the attribute, as illustrated in the
following example of an object instance based on <TT>MyTest</TT>:
<BR>
<IMG
 WIDTH="464" HEIGHT="42" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.gif"
 ALT="\begin{example}
&lt;MyTest attributeA=''foo'' attributeB=''bar''&gt;
&lt;attributeC anotherAttribute=''2'' yetAnotherAttribute=''4.3''/&gt;
&lt;/MyTest&gt;
\end{example}">
<BR>
Note how the attribute <TT>attributeC</TT> is written out as a separate XML
subelement, but the type of <TT>attributeC</TT> is not explicitly stated in
the data object.  This is in parallel to how the type also ends up hidden
in the programming language example involving object <code>obj</code> given
above.  Only the label <TT>attributeC</TT> and the attributes
<TT>anotherAttribute</TT> and <TT>yetAnotherAttribute</TT> appear.

<P>
Here is the XML Schema definition corresponding to the class diagram above:
<BR>
<IMG
 WIDTH="450" HEIGHT="140" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.gif"
 ALT="\begin{exampleTight}
&lt;xs:complexType name=''AttrCType''&gt;
&lt;xs:attribute name=''a...
...nt name=''attributeC'' type=''AttrCType''/&gt;
&lt;/xs:complexType&gt;
\end{exampleTight}">
<BR>

<P>
The only naming convention defined here for complex types is that the names
should begin with a capital letter.  However, it is a good idea to make the
name of a complex type reflect the attribute to which it is connected.
(E.g., for an attribute named <TT>version</TT>, the complex type might be
named <TT>Version</TT>.)

<P>

<P>

<H2><A NAME="SECTION00033000000000000000"></A>
<A NAME="sub:links"></A>
<BR>
3.3 Links
</H2>

<P>
A link is a reference to another part of the same database object or to a
completely separate database object.  It is a way of referring or pointing
to part of an object, or to a whole other object, by name, without
incorporating the actual physical object itself.  Two different approaches
apply in the two cases, one for intra-object links and one for inter-object
links.  They have parallels in XML, and the present notation reflects the
approach used in XML.

<P>

<H3><A NAME="SECTION00033100000000000000"></A>
<A NAME="subsub:intra"></A>
<BR>
3.3.1 Intra-Object Links
</H3>

<P>
In XML, links between elements within the same object can be handled
using a particular set of data types that are treated specially by XML
parsers.  The basic idea is the following.  The attribute that contains the
link itself must have the type <TT>IDREF</TT>; the referenced component (the
target) must have an attribute of type <TT>ID</TT>.  Components of an object
or a particular XML data stream are given unique identifiers assigned to
attributes of type <TT>ID</TT>.  Uniqueness of identifiers is enforced by
XML parsers, which are required to collect all attribute values of type
<TT>ID</TT> and verify their uniqueness within an XML document or data
stream.  An <TT>IDREF</TT> value is required by the XML standard to match
<I>some</I> <TT>ID</TT> attribute within a given data stream or document, or
else the XML parser must generate an error&nbsp;(Biron and Malhotra, 2000). The
effect of this is that XML parsers enforce the rule that a link to a
component in an object or data stream does in fact refer to a component
that is actually present.

<P>
The type <TT>ID</TT> is defined as being a token beginning with a letter or
one of two possible punctuation characters (specifically, underscore or
colon), and continuing with letters, digits, hyphens, underscores, colons,
or full stops, collectively known as <I>name characters</I>&nbsp;(Thompson et
al., 2000).  There is also a list version of <TT>IDREF</TT> called
<TT>IDREFS</TT> that is not necessary in the present context because of how
lists are handled in this notation; see Section&nbsp;<A HREF="notation.html#sub:list-attributes">3.5</A>.

<P>
In order to use this XML facility, the notation described here follows the
XML approach in using attributes of type <TT>ID</TT> and <TT>IDREF</TT> to
effectuate linking.  The convention adhered to here is that objects that
can be targets of links need to have an attribute named <TT>id</TT> of type
<TT>ID</TT>.  References to these objects or object components must be made
using attributes of type <TT>IDREF</TT>.

<P>
The following is a example of a class definition that uses intra-object linking:
<BLOCKQUOTE>
<!-- MATH
 $\includegraphics[scale = 0.7]{id-example}$
 -->
<IMG
 WIDTH="367" HEIGHT="96" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.gif"
 ALT="\includegraphics[scale = 0.7]{id-example}">
</BLOCKQUOTE>
Here is the XML Schema corresponding to the definition above:
<BR>
<IMG
 WIDTH="645" HEIGHT="221" ALIGN="BOTTOM" BORDER="0"
 SRC="img11.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''CType''&gt;
&lt;xs:attribute name=''id'' type=...
...tribute name=''whichCToUse'' type=''xs:IDREF''/&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR>

<P>

<P>
And the following is an example XML stream that makes use of the
definition above:
<BR>
<IMG
 WIDTH="645" HEIGHT="102" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.gif"
 ALT="\begin{example}
&lt;ReferenceExample attributeA=''something'' attributeB=''somethin...
...'c3'' someValue=''99''/&gt;
&lt;/listOfAttributeCs&gt;
&lt;/ReferenceExample&gt;
\end{example}">
<BR>
In the example above, each item in the <TT>listOfAttributeCs</TT> element
has a different value in the <TT>id</TT> attribute, and the attribute
<TT>whichCToUse</TT> refers to one of the items in the list by its
<TT>id</TT> value.

<P>
It is worth noting in passing that this approach can be used to represent
graph structures in XML.  By assigning <TT>ID</TT> type identifiers to
different elements in a data structure, it is possible to have elements
link to each other and thereby allow full graph-structured data to be
represented.

<P>

<H3><A NAME="SECTION00033200000000000000"></A>
<A NAME="subsub:inter"></A>
<BR>
3.3.2 Inter-Object Links
</H3>

<P>
Links may be established between separate objects (i.e., objects in
separate XML data streams or documents).  In UML, a link between two
conceptually separate object classes is indicated by drawing a line between
them.  Such an <I>association line</I> can be directed (i.e., an arrow)
when the connection is always from one particular class to the other, and a
third class can be associated with the connection to define additional
properties.  To handle inter-object links in the present framework, all
three of these features need to be invoked.  The following example
illustrates these ideas:
<BLOCKQUOTE>
<!-- MATH
 $\includegraphics[scale = 0.7]{two-classes}$
 -->
<IMG
 WIDTH="409" HEIGHT="86" ALIGN="BOTTOM" BORDER="0"
 SRC="img13.gif"
 ALT="\includegraphics[scale = 0.7]{two-classes}">
</BLOCKQUOTE>
The meaning of the above is: <TT>Elevator</TT> consists of all the
attributes within the box of the class definition, <I>plus</I> the
attribute <TT>controller</TT>, which is a link of type <TT>XLink</TT> to an
object of class <TT>ElevatorControl</TT>.  By UML convention, the attribute
<TT>controller</TT> does not appear in the <TT>Elevator</TT> box itself.  In
reading UML diagrams containing associations between classes, it is
therefore important to count <I>both</I> the attributes within the class
box as well as the attributes shown on association lines.

<P>
Here is the same example in textual form:
<BLOCKQUOTE>
</FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">   
  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="317">
<TR><TD>
      <PRE><TT>
        <TT>Elevator</TT>
<BR>
<BR><TT>type</TT>:		<TT>string</TT>
<BR><TT>name</TT>:		<TT>string</TT>
<BR><TT>controller</TT>:		<TT>XLink  {link to <TT>ElevatorControl</TT>}</TT>
<BR>
</TT></PRE></TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="202">
<TR><TD>
      <PRE><TT>
        <TT>ElevatorControl</TT>
<BR>
<BR><TT>model</TT>:		<TT>string</TT>
<BR><TT>operatingFloors</TT>:		<TT>integer</TT>
<BR><TT>numberOfButtons</TT>:		<TT>integer</TT>      
</TT></PRE></TD></TR>
</TABLE></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE></BLOCKQUOTE>

<P>
A link in the present notation is implemented by using a specific complex
type, <TT>XLink</TT>, and then defining attributes that serve as links to be
of this type.  The type <TT>XLink</TT> is meant to signify the use of the
<I>XML Linking Language</I>, XLink&nbsp;(DeRose et al., 2000; St. Laurent, 200).
<TT>XLink</TT> uses the two essential attributes that define an XML link,
namely <TT>xlink:type</TT> and <TT>xlink:href</TT>.  The former can be
given a default value, so only <TT>xlink:href</TT> needs to be set in
actual use.  The form of the value of the <TT>xlink:href</TT> reference
target will depend on the particular server storing the database, but the
form will generally be a <TT>uriReference</TT> (see
Figure&nbsp;<A HREF="notation.html#fig:simple-types">1</A>).  Unfortunately, there is no method for
indicating the intended type of the target object in a simple XLink link;
consistency between the desired type and the actual type of the target
referenced by the link must be handled by the program.

<P>
The following XML Schema defines the classes <TT>Elevator</TT> and
<TT>XLink</TT> used in the example above; the class <TT>ElevatorControl</TT>
is assumed to be defined in a separate Schema:
<BR>
<IMG
 WIDTH="585" HEIGHT="146" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''XLink''&gt;
&lt;xs:attribute name=''xlink:type...
...&lt;xs:element name=''controller'' type=''XLink''/&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR>
The following is an example of a portion of XML data that uses the Schema:
<BR>
<IMG
 WIDTH="532" HEIGHT="40" ALIGN="BOTTOM" BORDER="0"
 SRC="img15.gif"
 ALT="\begin{example}
&lt;Elevator type=''Argo K21'' name=''Main''&gt;
&lt;controller xlink:href=''http://www.myserver.net/db/controllers/kc9''/&gt;
&lt;/Elevator&gt;
\end{example}">
<BR>

<P>
For the limited applications that are the domain of the present document,
only the ``simple'' XLink type is required&nbsp;(DeRose et al., 2000); more
elaborate versions of XLink also exist, but are not used here.

<P>

<H2><A NAME="SECTION00034000000000000000"></A>
<A NAME="sub:inclusion"></A>
<BR>
3.4 Inclusion
</H2>

<P>
The kinds of links described in the previous section point to other
structures without actually including the structures at the point where the
reference occurs.  In some limited situations, it is also useful to include
one data object directly inside another.  For example, programs
communicating data structures in the absence of database facilities may
need to package up entire objects and send them without leaving links that
the recipient may not be able to dereference.  Expressing object inclusion
of this kind requires a variation of the link notation defined in the
previous section.

<P>
Inclusion of objects in this fashion is most appropriately handled in XML
using <I>XInclude</I>, the XML Inclusions definition&nbsp;(Marsh and Orchard,
2000).  There are currently significant limitations to using XInclude.  It
is a work in progress and not yet a standard, so the actual syntax of
XInclude described here may vary in the future; moreover, no XML processors
support XInclude yet.  Nevertheless, XInclude is used in the present
notation in anticipation of its eventual standardization.  The XInclude
features used here are extremely limited, so implementing support for
XInclude in application programs should not be difficult.

<P>
Here is an example of an object inclusion:
<BLOCKQUOTE>
<!-- MATH
 $\includegraphics[scale = 0.7]{xinclude}$
 -->
<IMG
 WIDTH="427" HEIGHT="78" ALIGN="BOTTOM" BORDER="0"
 SRC="img16.gif"
 ALT="\includegraphics[scale = 0.7]{xinclude}">
</BLOCKQUOTE>

<P>
The following XML Schema defines the class <TT>Bottle</TT> used in the
example above; the class <TT>Brand</TT> is assumed to be defined elsewhere
in a separate Schema:
<BR>
<IMG
 WIDTH="457" HEIGHT="132" ALIGN="BOTTOM" BORDER="0"
 SRC="img17.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''XInclude''&gt;
&lt;xs:attribute name=''xinclud...
...
&lt;xs:element name=''brand'' type=''XInclude''/&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR>
The following is an example of XML using the Schema:
<BR>
<IMG
 WIDTH="502" HEIGHT="40" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.gif"
 ALT="\begin{example}
&lt;Bottle capacity=''5.0'' capacity_units=''gallon''&gt;
&lt;brand xinclude:href=''http://www.myserver.net/bottledb/maker52''/&gt;
&lt;/Bottle&gt;
\end{example}">
<BR>

<P>

<H2><A NAME="SECTION00035000000000000000"></A>
<A NAME="sub:list-attributes"></A>
<BR>
3.5 Lists
</H2>

<P>
An attribute can be a list of simple types, or a list of complex types, or
a list of link or inclusion types.  All items in the list must have the
same type.  In some programming languages such as Java or C, a list might
be represented as a vector or array.

<P>

<P></P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="242" HEIGHT="175" BORDER="0"
 SRC="img19.gif"
 ALT="\begin{wrapfigure}{r}{2.2in}
\begin{center}
\begin{tabular}{rl}
1 &amp; exactly o...
... zero or more\\
1..* &amp; one or more
\end{tabular} \end{center}\end{wrapfigure}">
</DIV>
<P></P>
In the diagrammatic and textual forms of the current notation, lists are
expressed using a style loosely based on C and Java-style array notation,
with a multiplicity specifier enclosed in square brackets.  The
multiplicity specifier consists of numerals or the asterisk
character, optionally separated by commas or `..'  (the last to indicate a
range).  Asterisk means ``zero or more''.  For example,
``<TT>somevar[10]: integer</TT>'' means that <TT>somevar</TT> is a list of
exactly ten integers.  Similarly, ``<TT>author[1..*]: string</TT>'' means
that attribute <TT>author</TT> is a list of one or more strings.  The table
at the right gives a number of other examples of multiplicity
specifications.

<P>
Regardless of whether the type of an attribute is simple, complex, or a
link, the approach used here to translate from a list form into XML is the
same: create a subelement named <TT>listOfs</TT>,
where the blank indicates the capitalized name of the attribute, and then
put a list of elements named after the attribute as the content of the
<TT>listOfs</TT> element.  Small variations need
to be introduced for coping with various details of different data types,
and these are explained in the following paragraphs.

<P>

<H3><A NAME="SECTION00035100000000000000">
3.5.1 Lists of Simple Types</A>
</H3>

<P>
Perhaps the most natural way of representing a list of simple attributes
would be to have multiple instances of the same attribute on an
object, such as <code>&lt;Object somevar="value1" somevar="value2" ...&gt;</code>
However, XML does not allow more than one element attribute of the same
name, therefore an attribute that is a list of simple types must be
translated into a sequence of subelements.  The approach adopted here is to
use a series of subelements named after the attribute, each having a single
element attribute named <TT>value</TT> used to store the actual value of
the item.  Here is an example:
<BLOCKQUOTE>
</FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">   
  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="173">
<TR><TD>
      <!-- MATH
 $\includegraphics[scale = 0.7]{simple-attr-list}$
 -->
<IMG
 WIDTH="167" HEIGHT="64" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.gif"
 ALT="\includegraphics[scale = 0.7]{simple-attr-list}">
    </TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 
    </FONT><TABLE  WIDTH="461">
<TR><TD>
<BR>
<IMG
 WIDTH="412" HEIGHT="132" ALIGN="BOTTOM" BORDER="0"
 SRC="img21.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''SomeThing''&gt;
&lt;xs:attribute name=''attrib...
...'unbounded''/&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR></TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">     </FONT></TD>
<TD></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    <I>UML Form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>XML Schema Form</I>
  </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></BLOCKQUOTE>
The definitions above would allow product XML data objects such as the
following; note how the values of the <TT>attributeB</TT> strings are
recorded on the <TT>value</TT> attributes in the elements of the list:
<BR>
<IMG
 WIDTH="292" HEIGHT="102" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.gif"
 ALT="\begin{example}
&lt;SomeThing attributeA=''123''&gt;
&lt;listOfAttributeBs&gt;
&lt;attributeB...
...ibuteB value=''third string''/&gt;
&lt;/listOfAttributeBs&gt;
&lt;/SomeThing&gt;
\end{example}">
<BR>

<P>

<H3><A NAME="SECTION00035200000000000000">
3.5.2 Lists of Complex Types</A>
</H3>

<P>
The approach to encoding a complex attribute described in
Section&nbsp;<A HREF="notation.html#sub:complex-attributes">3.2</A> involves translating it into a
subelement.  The approach to encoding a list of complex types parallels the
one for encoding simple types, but without the need for an additional
<TT>value</TT> attribute.  The elements in the list are each identical to
the element that would be present if there were no list and only a single
complex attribute.  

<P>
The following example definition illustrates the idea:
<BLOCKQUOTE>
</FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">   
  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="161">
<TR><TD>
      <!-- MATH
 $\includegraphics[scale = 0.7]{complex-attr-list}$
 -->
<IMG
 WIDTH="121" HEIGHT="149" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.gif"
 ALT="\includegraphics[scale = 0.7]{complex-attr-list}">
    </TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 
    </FONT><TABLE  WIDTH="461">
<TR><TD>
<BR>
<IMG
 WIDTH="412" HEIGHT="206" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''Point''&gt;
&lt;xs:attribute name=''x'' type='...
...'unbounded''/&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR></TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">     </FONT></TD>
<TD></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    <I>UML Form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>XML Schema Form</I>
  </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></BLOCKQUOTE>
The definitions above would allow product XML data objects such as the
following:
<BR>
<IMG
 WIDTH="209" HEIGHT="102" ALIGN="BOTTOM" BORDER="0"
 SRC="img25.gif"
 ALT="\begin{example}
&lt;Triangle name=''t1''&gt;
&lt;listOfPoints&gt;
&lt;point x=''2.2'' y=''1.4...
...4.0''/&gt;
&lt;point x=''0.1'' y=''1.4''/&gt;
&lt;/listOfPoints&gt;
&lt;/Triangle&gt;
\end{example}">
<BR>

<P>

<H3><A NAME="SECTION00035300000000000000">
3.5.3 Lists of Links and Inclusions</A>
</H3>

<P>
The case of intra-object links is identical to the case of a list of simple
attributes discussed above.  Intra-object links
(Section&nbsp;<A HREF="notation.html#subsub:intra">3.3.1</A>) are implemented simply by using the XML type
<TT>IDREF</TT>, so a list of links defined as, for example,
<TT>itemRef[0..*]: IDREF</TT>, turn into a list of elements of the
form <code>&lt;itemRef value="..."/&gt;</code>.

<P>
In the case of inter-object links or inclusions, multiplicity involving
separate objects is expressed in UML with numerals on the links joining two
object classes together.  For example, if in the <TT>Elevator</TT> example
of Section&nbsp;<A HREF="notation.html#sub:links">3.3</A>, <TT>controller</TT> had actually been a list of
zero or more links to <TT>ElevatorControl</TT> class objects, then the
corresponding UML diagram would be:
<BLOCKQUOTE>
<!-- MATH
 $\includegraphics[scale = 0.7]{two-classes-multi}$
 -->
<IMG
 WIDTH="409" HEIGHT="88" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.gif"
 ALT="\includegraphics[scale = 0.7]{two-classes-multi}">
</BLOCKQUOTE>
By convention, if the relationship is 1-to-1, the two numeral 1's are
normally omitted from the association line in a UML diagram; see the
example diagrams in Sections&nbsp;<A HREF="notation.html#subsub:inter">3.3.2</A> and <A HREF="notation.html#sub:inclusion">3.4</A>.
The absence of any numerals on either end of an association line implies 1.

<P>
As in the case of lists of complex types, the elements used in the list of
links or list of inclusions do not need any additional attributes; each
list item has the same form as a single element constructed from a
link attribute as described in Section&nbsp;<A HREF="notation.html#sub:links">3.3</A>.  Here is an example
definition:
<BLOCKQUOTE>
</FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="150">
<TR><TD>
      <!-- MATH
 $\includegraphics[scale = 0.7]{link-attr-list}$
 -->
<IMG
 WIDTH="129" HEIGHT="68" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.gif"
 ALT="\includegraphics[scale = 0.7]{link-attr-list}">
    </TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 
    </FONT><TABLE  WIDTH="461">
<TR><TD>
<BR>
<IMG
 WIDTH="412" HEIGHT="132" ALIGN="BOTTOM" BORDER="0"
 SRC="img28.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''Article''&gt;
&lt;xs:attribute name=''name'' t...
...'unbounded''/&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR></TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">     </FONT></TD>
<TD></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    <I>UML Form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>XML Schema Form</I>
  </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></BLOCKQUOTE>
The following is an XML data object based on the definitions above:
<BR>
<IMG
 WIDTH="464" HEIGHT="85" ALIGN="BOTTOM" BORDER="0"
 SRC="img29.gif"
 ALT="\begin{example}
&lt;Article name=''t1''&gt;
&lt;listOfAuthors&gt;
&lt;author xlink:href=''htt...
...ttp://www.myserver.net/db/author54''/&gt;
&lt;/listOfPoints&gt;
&lt;/Article&gt;
\end{example}">
<BR>

<P>
Although the examples above were given in terms of <TT>XLink</TT> links, the
same approach also applies to <TT>XInclude</TT> inclusions.

<P>

<H2><A NAME="SECTION00036000000000000000">
3.6 Element Values</A>
</H2>

<P>
In the present approach to translating UML to XML, most object class
attributes are encoded as attributes on an XML element, and subelements are
likewise used to store information using attributes.  But in addition to
the way that simple and complex types are used here, XML also allows
elements to have content values.  Consider the following example:
<BR>
<IMG
 WIDTH="531" HEIGHT="87" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.gif"
 ALT="\begin{example}
&lt;ContainerExample title=''This is a title''&gt;
&lt;bigValue&gt;
This i...
...to put inside an attribute value.
&lt;/bigValue&gt;
&lt;/ContainerExample&gt;
\end{example}">
<BR>
The element <TT>bigValue</TT> above has no attributes, but does have a
value.  Expressing this in UML requires a notation that is not part of UML
proper, so it is necessary to introduce two minor extensions to UML for
this purpose.  The two extensions apply to two different cases:

<OL>
<LI><I>An attribute representing a container</I>.  This is the case of
  <TT>ContainerExample</TT> illustrated above, where an object's attribute
  is a container for a value in the sense that XML elements can have
  values.  The modified UML notation adopted here is to place the type in
  parentheses.  The parentheses signify that the attribute is special, with
  not actually represented as an attribute in XML but rather as an element
  whose value is significant.  Here follows the definition corresponding to
  the example given above:
  <BLOCKQUOTE>
</FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">     
    </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
      </FONT><TABLE  WIDTH="150">
<TR><TD>
        <DIV ALIGN="CENTER">
<!-- MATH
 $\includegraphics[scale = 0.7]{attribute-container}$
 -->
<IMG
 WIDTH="135" HEIGHT="65" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.gif"
 ALT="\includegraphics[scale = 0.7]{attribute-container}">
        
</DIV></TD></TR>
</TABLE><FONT SIZE="-1">
      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 
      </FONT><TABLE  WIDTH="432">
<TR><TD>
<BR>
<IMG
 WIDTH="374" HEIGHT="57" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''ContainerExample''&gt;
&lt;xs:attribute name='...
...s:element name=''bigValue'' type=''xs:string''/&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR></TD></TR>
</TABLE><FONT SIZE="-1">
      </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">     </FONT></TD>
<TD></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
      <I>UML Form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>XML Schema Form</I>
    </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></BLOCKQUOTE>
  Restriction: The type of the container attribute in the definition must
  be simple; it cannot be another a complex type.  (If the type were
  allowed to be complex, the situation would simply be identical to an
  ordinary complex attribute.)

<P>
</LI>
<LI><I>A class containing a value</I>.  For this case, the modified UML notation
  adopted here is to place the type of the container in parentheses
  following the class name.  For example,
  <BLOCKQUOTE>
</FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">     
    </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
      </FONT><TABLE  WIDTH="150">
<TR><TD>
        <DIV ALIGN="CENTER">
<!-- MATH
 $\includegraphics[scale = 0.7]{class-container}$
 -->
<IMG
 WIDTH="141" HEIGHT="49" ALIGN="BOTTOM" BORDER="0"
 SRC="img33.gif"
 ALT="\includegraphics[scale = 0.7]{class-container}">
        
</DIV></TD></TR>
</TABLE><FONT SIZE="-1">
      </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 
      </FONT><TABLE  WIDTH="461">
<TR><TD>
<BR>
<IMG
 WIDTH="412" HEIGHT="57" ALIGN="BOTTOM" BORDER="0"
 SRC="img34.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''Whatever'' content=''textOnly''&gt;
&lt;xs:att...
...te name=''type'' use=''fixed'' value=''XHTML''/&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR></TD></TR>
</TABLE><FONT SIZE="-1">
      </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">     </FONT></TD>
<TD></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
      <I>UML Form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>XML Schema Form</I>
    </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></BLOCKQUOTE>
  This allows the following kind of XML data object:
<BR>
<IMG
 WIDTH="307" HEIGHT="40" ALIGN="BOTTOM" BORDER="0"
 SRC="img35.gif"
 ALT="\begin{example}
&lt;Whatever bigDeal=''This is an attribute''&gt;
This has a value, but no subelements.
&lt;/Whatever&gt;
\end{example}">
<BR>
The XML Schema for this case uses the special property
  <TT>content="textOnly"</TT>, which indicates that the XML element value
  can only contain data, not subelements.  This unfortunately imposes a
  limitation on the resulting representation: XML parsers will not check
  the datatype of the content in instance objects, treating it simply as
  text.  In order to avoid losing the type information altogether, the
  original type is recorded on an attribute called <TT>type</TT>, using a
  fixed value corresponding to the type stated in parentheses next to the
  class definition.  Although XML parsers will not check the content in
  instance objects, programs that receive objects of this class can use the
  type information to perform their own checking.

<P>
Restrictions: (1) The type of the container attribute must be a
  simple type; it cannot be a complex type.  (2) None of the
  attributes in the rest of the object class definition can be complex; all
  must have simple types.

<P>
</LI>
</OL>  

<P>

<H2><A NAME="SECTION00037000000000000000">
3.7 Constraints on Attribute Values</A>
</H2>

<P>
It is important to be able to express constraints on the values of
attributes.  A constraint refers to a limitation or restriction on the
possible content or state of an attribute.  For example, it may be useful
to specify that a given integer attribute cannot have a value less than
zero, or that a given string attribute can only take on values from a
limited vocabulary.

<P>
There are two standard ways in UML to express constraints.  One approach
consists of adding a constraint expression in curly braces following the
definition of an attribute, as in the UML shown in the following example:
<BLOCKQUOTE>
 
  </FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="230">
<TR><TD>
      <PRE><TT>
        <TT>AnExample</TT>
<BR>
<BR><TT>attrA</TT>:		<TT>integer</TT>
<BR><TT>attrB</TT>:		<TT>string</TT>		<TT>{"val1", "val2", "val3"}</TT>
<BR>
</TT></PRE>
      <I>Textual form</I>
    </TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></TD>
<TD ALIGN="CENTER"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="346">
<TR><TD>
      <!-- MATH
 $\includegraphics[scale = 0.7]{someschema-constraints}$
 -->
<IMG
 WIDTH="246" HEIGHT="66" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.gif"
 ALT="\includegraphics[scale = 0.7]{someschema-constraints}">
<BR>      <I>UML form</I>
    </TD></TR>
</TABLE></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></BLOCKQUOTE>
Alternatively, in a UML diagram, the constraints can be placed in an
external text box and a line can be drawn from the box to the attribute in
question, as in the following:
<BLOCKQUOTE>
<!-- MATH
 $\includegraphics[scale = 0.7]{someschema-constraints-boxed}$
 -->
<IMG
 WIDTH="333" HEIGHT="66" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.gif"
 ALT="\includegraphics[scale = 0.7]{someschema-constraints-boxed}">
</BLOCKQUOTE>

<P>
For defining constraints in UML, some authors use Object Constraint
Language, a declarative language based on set theory&nbsp;(Oestereich, 1999).
For the goals of the present notation, it is more convenient to express
constraints either in a simple stylized form (as in the
immediately-preceding examples) or using XML Schema language.  The
following are some examples that have arisen in practice:

<UL>
<LI><I>String value chosen from a strictly limited vocabulary</I>.  XML
  Schema defines several mechanisms for constraining values of attributes.
  A particularly useful one is the <TT>enumeration</TT> component.  Here is
  an example of an XML Schema constraining the values of an attribute to a
  limited set of three specific strings for the class <TT>AnExample</TT>
  defined above:
<BR>
<IMG
 WIDTH="359" HEIGHT="146" ALIGN="BOTTOM" BORDER="0"
 SRC="img38.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''AnExample''&gt;
&lt;xs:attribute name=''attrA'...
...ue=''val3''/&gt;
&lt;/xs:simpleType&gt;
&lt;/xs:attribute&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR>

<P>
</LI>
<LI><I>Optional attribute</I>.  Sometimes an attribute in a class should
  be considered optional.  For these situations, the attribute should be
  given the XML Schema property <TT>minOccurs="0"</TT>.  (The default value
  of <TT>minOccurs</TT> is 1.)
  <BLOCKQUOTE>
<!-- MATH
 $\includegraphics[scale = 0.7]{minoccurs}$
 -->
<IMG
 WIDTH="350" HEIGHT="63" ALIGN="BOTTOM" BORDER="0"
 SRC="img39.gif"
 ALT="\includegraphics[scale = 0.7]{minoccurs}">
</BLOCKQUOTE>
  <I>UML Form</I>
<BR>
<IMG
 WIDTH="495" HEIGHT="57" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''YetAnotherExample''&gt;
&lt;xs:attribute name=...
...:attribute name=''dateValue'' type=''xs:date''/&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR>
  <I>XML Schema Form</I>

<P>
</LI>
<LI><I>Minimum and maximum range values on numeric attributes</I>.  The
  upper and lower value boundaries for an attribute having a numeric value
  can be defined using the XML Schema <TT>minExclusive</TT>,
  <TT>minInclusive</TT>, <TT>maxInclusive</TT>, and <TT>maxExclusive</TT>
  properties.  For instance:

<P>
<BR>
<BR>
  <BLOCKQUOTE>
<!-- MATH
 $\includegraphics[scale = 0.7]{min-max}$
 -->
<IMG
 WIDTH="428" HEIGHT="70" ALIGN="BOTTOM" BORDER="0"
 SRC="img41.gif"
 ALT="\includegraphics[scale = 0.7]{min-max}">
</BLOCKQUOTE>
  <I>UML Form</I>
<BR>
<IMG
 WIDTH="660" HEIGHT="57" ALIGN="BOTTOM" BORDER="0"
 SRC="img42.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''RangeExample''&gt;
&lt;xs:attribute name=''int...
...ue'' type=''xs:double'' maxExclusive=''0.001''/&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR>
  <I>XML Schema Form</I>

<P>
The first attribute is limited to integer values from 1 to 10,
  inclusive; the second attribute is constrained to values no less than
  0.001, exclusive.

<P>
</LI>
</UL>

<P>
There are many more situations that call for the use of constraints and
that are not covered by the examples above.  For such other cases, it is up
to users of the present notation to devise appropriate expressions of
constraints using XML Schema terms or other simple expressions.  The
constraint terms available in XML Schema are defined in the XML Schema
specification&nbsp;(Biron and Malhotra, 2000; Thompson et al. 2000).

<P>

<H2><A NAME="SECTION00038000000000000000">
3.8 Specifying Units</A>
</H2>

<P>
It is often important to provide information about the units associated
with a numerical attribute.  In the approach to XML representations used
here, there are two alternatives for specifying units conveniently.

<P>
The first approach is to define, for each relevant attribute, another
attribute whose name has the suffix <TT>_units</TT> and whose type is a
string, to represent the units being used for the value stored in the
attribute.  The following is an example:
<BLOCKQUOTE>
</FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">   
  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="196">
<TR><TD>
      <!-- MATH
 $\includegraphics[scale = 0.7]{sampleschema-units}$
 -->
<IMG
 WIDTH="185" HEIGHT="97" ALIGN="BOTTOM" BORDER="0"
 SRC="img43.gif"
 ALT="\includegraphics[scale = 0.7]{sampleschema-units}">
    </TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="369">
<TR><TD>
      <PRE><TT>
        <code>&lt;xs:complexType name="Sample"&gt;</code>
<BR><code>&lt;xs:attribute name="title" type="xs:string"/&gt;</code>
<BR><code>&lt;xs:attribute name="description" type="xs:string"/&gt;</code>
<BR><code>&lt;xs:attribute name="sampleValue" type="xs:integer"/&gt;</code>
<BR><code>&lt;xs:attribute name="sampleValue_units" type="xs:string"/&gt;</code>
<BR><code>&lt;/xs:complexType&gt;</code>      
</TT></PRE></TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    </FONT></TD>
<TD></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    <I>UML Form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>XML Schema</I>
  </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></BLOCKQUOTE>

<P>
The second approach is suitable for groups of attributes or substructures
that all use the same unit.  In that case, it may be simpler to define an
attribute at the class level that sets the units for a whole object.

<P>
In order to maximize the utility of having unit specifications, a given
project should define a specific XML type for the units it needs to use.
This specification should take the form of a datatype (perhaps called
<TT>Units</TT>), defined in a separate XML Schema, consisting of an
enumeration of strings.  Here is a partial example of such an XML Schema:
<BR>
<IMG
 WIDTH="337" HEIGHT="117" ALIGN="BOTTOM" BORDER="0"
 SRC="img44.gif"
 ALT="\begin{example}
&lt;xs:simpleType name=''Units'' base=''xs:string''&gt;
&lt;xs:enumerati...
...n value=''mm''/&gt;
\par &lt;!-- and so on ... --&gt;
\par &lt;/xs:simpleType&gt;
\end{example}">
<BR>

<P>

<H2><A NAME="SECTION00039000000000000000">
3.9 Inheritance</A>
</H2>

<P>
Inheritance allows an object class to be defined as an extension or
derivation of another class.  In textual form, the inheritance relationship
can be written on the same line as the name of the class definition; in
graphical UML form, inheritance is expressed using an open-ended arrow
drawn from an inheriting class to the inherited-from class.  The following
illustrates both forms:

<P>
<BLOCKQUOTE>
</FONT><FONT SIZE="-1">
<BR><FONT SIZE="-1">   
  </FONT><TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">
    </FONT><TABLE  WIDTH="184">
<TR><TD>
      <PRE><TT>
        <TT>SomeOtherClass</TT>
<BR>
<BR><TT>myValue</TT>:		<TT>string</TT>      
</TT></PRE>
      <BR>
<BR>
      <PRE><TT>
        <TT>SomeClass extends SomeOtherClass</TT>
<BR>
<BR><TT>attrA</TT>:		<TT>string</TT>      
</TT></PRE></TD></TR>
</TABLE><FONT SIZE="-1">
    </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> 
    </FONT><TABLE  WIDTH="230">
<TR><TD>
      <!-- MATH
 $\includegraphics[scale = 0.7]{someschema-inherit}$
 -->
<IMG
 WIDTH="155" HEIGHT="134" ALIGN="BOTTOM" BORDER="0"
 SRC="img45.gif"
 ALT="\includegraphics[scale = 0.7]{someschema-inherit}"></TD></TR>
</TABLE><FONT SIZE="-1"> </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1">  </FONT></TD>
<TD></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="LEFT"><FONT SIZE="-1"> 
    <I>Textual form</I> </FONT></TD>
<TD ALIGN="LEFT"><FONT SIZE="-1"> <I>UML form</I>
  </FONT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE><FONT SIZE="-1">
  </FONT></BLOCKQUOTE>

<P>
The meaning of the above is that <TT>SomeClass</TT> inherits from
<TT>SomeOtherClass</TT> and augments the latter type's definition by adding
an attribute of its own.  <TT>SomeClass</TT> therefore has as attributes
<I>both</I> <TT>attrA</TT> and <TT>myValue</TT>, even though the box
defining <TT>SomeClass</TT> itself does not mention the second one.
<TT>SomeOtherClass</TT> has only one attribute, <TT>myValue</TT>.

<P>
In XML, inheritance can be implemented using the <TT>base</TT> and
<TT>derivedBy</TT> mechanisms on a type definition.  This allows an XML
element/class definition to be based on another element.  The following is
an XML Schema for the example above:
<BR>
<IMG
 WIDTH="585" HEIGHT="102" ALIGN="BOTTOM" BORDER="0"
 SRC="img46.gif"
 ALT="\begin{example}
&lt;xs:complexType name=''SomeOtherClass''&gt;
&lt;xs:attribute name=''m...
...xs:attribute name=''attrA'' type=''xs:string''/&gt;
&lt;/xs:complexType&gt;
\end{example}">
<BR>

<P>

<H1><A NAME="SECTION00040000000000000000">
4 Summary</A>
</H1>

<P>
The notation proposed in this document is based on a subset of what could
be used and what UML provides.  It is not intended to cover the full scope
of UML or XML.  The subset was chosen to be as simple as possible yet allow
the expression of the kinds of data structures that need to be encoded in
XML for the ERATO Kitano Systems Biology workbench.

<P>
The notation proposed here is not carved in stone, and will undoubtedly
continue to evolve.  Please send your feedback about any aspect of this
document to the author.

<P>

<H1><A NAME="SECTION00050000000000000000">
5 Acknowledgements</A>
</H1>

<P>
This notation was developed as a result of joint work between fellow
members of the Caltech ERATO Kitano Systems Biology team (Herbert Sauro,
Andrew Finney, Hamid Bolouri) and the Modeler's Workspace project (Kavita
Shankar, David Beeman, Sara Emardson).  I thank Greg Hood, Fred Howel and
Nigel Goddard for additional comments on early versions of this notation.

<P>
This research has been supported by a grant from the NIMH Human Brain
Project, an Academic Equipment Grant (#EDUD-7824-000127-US) from Sun
Microsystems, Inc., and a gift from the Microsoft Corporation.

<P>

<P>

<H1><A NAME="SECTION00060000000000000000">
A. References</A>
</H1>

<P>

<P>
<DIV ALIGN="LEFT">
</DIV>
<P>
<DIV ALIGN="LEFT">Biron, P.&nbsp;V., and Malhotra, A.  (2000).  XML Schema Part 2: Datatypes (W3C
Working Draft 7 April 2000).  Available via the World Wide Web at
<TT><A NAME="tex2html5"
  HREF="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">Bosak, J., and Bray, T. (1999).  XML and the Second-Generation Web.
Scientific American, May.  Also available via the World Wide Web at
<TT><A NAME="tex2html6"
  HREF="http://www.sciam.com/1999/0599issue/0599bosak.html">http://www.sciam.com/1999/0599issue/0599bosak.html</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">Box, D., Skonnard, A., and Lam, J.  (2000).  <I>Essential XML</I>.  Boston:
Addison-Wesley.
</DIV>
<P>
<DIV ALIGN="LEFT">Bray, T. (2000).  RE: When is an attribute an attribute?  Posting to the
<TT><A NAME="tex2html7"
  HREF="xml-dev">xml-dev</A></TT> mailing list, Apr 1998.  Available via the World Wide Web at
<TT><A NAME="tex2html8"
  HREF="http://www.oasis-open.org/cover/brayAttr980409.html">http://www.oasis-open.org/cover/brayAttr980409.html</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">Bray, T., Paoli, J., and Sperberg-McQueen, C.&nbsp;M. (1998). Extensible Markup
Language (XML) 1.0, W3C Recommendation 10-February-1998.  Available via the
World Wide Web at <TT><A NAME="tex2html9"
  HREF="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/1998/REC-xml-19980210</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">Cover, R.  (2000).  SGML/XML Elements versus Attributes: When Should I Use
Elements, and When Should I Use Attributes?   Available via the World Wide
Web at <TT><A NAME="tex2html10"
  HREF="http://www.oasis-open.org/cover/elementsAndAttrs.html">http://www.oasis-open.org/cover/elementsAndAttrs.html</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">DeRose, S., Maler, E., Orchard, D., and Trafford, B. (2000).  XML Linking
Language (XLink) Version 1.0 W3C Candidate Recommendation 3 July 2000.
Available via the World Wide Web at <TT><A NAME="tex2html11"
  HREF="http://www.w3.org/TR/xlink/">http://www.w3.org/TR/xlink/</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">Eriksson, H.-E., and Penker, M. (1998).  <I>UML Toolkit</I>.  New York: John Wiley
&amp; Sons.
</DIV>
<P>
<DIV ALIGN="LEFT">Fallside, D.&nbsp;C.  (2000).  XML Schema Part 0: Primer (W3C Working Draft, 7
April 2000).  Available via the World Wide Web at
<TT><A NAME="tex2html12"
  HREF="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">Marsh, J., and Orchard, D.  (2000).  XML Inclusions (XInclude) Version 1.0
(W3C Working Draft 17-July-2000).  Available via the World Wide Web at
<TT><A NAME="tex2html13"
  HREF="http://www.w3.org/TR/xinclude">http://www.w3.org/TR/xinclude</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">OMG (Object Management Group), (2000).  UML Resource Page.  Available via
the World Wide Web at <TT><A NAME="tex2html14"
  HREF="http://www.omg.org/technology/uml/">http://www.omg.org/technology/uml/</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">Oestereich, B.  (1999).  <I>Developing Software with UML: Object-Oriented
Analysis and Design in Practice</I>.  Addison-Wesley.
</DIV>
<P>
<DIV ALIGN="LEFT">St. Laurent, S. (2000).  <I>XML Elements of Style</I>.   New York: McGraw-Hill.
</DIV>
<P>
<DIV ALIGN="LEFT">Thompson, H.&nbsp;S., Beech, D., Maloney, M., and Mendelsohn, N. (2000).  XML
Schema Part 1: Structures (W3C Working Draft 7 April 2000).  Available via
the World Wide Web at <TT><A NAME="tex2html15"
  HREF="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</A></TT>.
</DIV>
<P>
<DIV ALIGN="LEFT">
</DIV>

<P>

<H1><A NAME="SECTION00070000000000000000">
About this document ...</A>
</H1>
 <STRONG>SCHUCS: A UML-Based Approach for Describing
<BR>
Data Representations Intended for XML Encoding</STRONG><P>
This document was generated using the
<A HREF="http://www-dsed.llnl.gov/files/programs/unix/latex2html/manual/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 99.2beta8 (1.46)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-white -split +0 -show_section_numbers -image_type gif -no_navigation -local_icons -discard -mkdir -dir html notation</TT>
<P>
The translation was initiated by  on 2001-05-25
<BR><HR>
<ADDRESS>

2001-05-25
</ADDRESS>
</BODY>
</HTML>
